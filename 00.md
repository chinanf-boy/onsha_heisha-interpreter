# イントロダクション

## 言語処理系の種類

言語処理系の種類は大きく分けでコンパイラとインタプリタがあります。

またそれぞれの方法でもバーチャルマシン（VM）つかってプログラムを実行する方法もあります。

### コンパイラ

ソースコードを機械語やバイトコードに変換する方式です。

```
ソースコード -> [[コンパイラ]] -> バイナリファイル -> [[ランタイム（システム,VM）]] -> 実行
```

### インタプリタ

ソースコードを逐次解釈しながら実行する方式です。

```
ソースコード -> [[コンパイラ -> ランタイム（インタプリタ処理系,VM）]] -> 実行
```

今回作成するのはこちらのタイプです。


## コンパイラの構成

コンパイラは次のように幾つかのフェーズに分けて処理を実行します。

1. 字句解析

    ソースコードを意味のあるトークンの列に変換します。

    * Lex
    * Flex

2. 構文解析

    トークンが文法に適合しているかをチェックする。場合によっては構文木を作成します。

    * Yacc
    * Bison

3. 最適化

    コード生成の前後に最適化処理を行います。

    定数の畳み込み、無意味な代入の削除、交換命令の削除などが挙げられます。


4. コード生成

    最終的に目的となるコード（マシンコード、バイトコード）を生成します。


分類はあくまで目安です。
コンパイラがこれらすべてを実行しているわけではありません。


## MiniMonkey Programinng Language

今回実装するインタプリタは [Writing An Interpreter In Go | Thorsten Ball](https://interpreterbook.com/) のMonkey Programming Languageのサブセットです。

特徴はつぎのとおりです。

* 四則演算
* 変数
* 整数型のみ
* 関数（高階関数、クロージャ）

```
1 + 2 + 3;       // => 6
1 + 2 * 3;       // => 7
(1 + 2) * 3;     // => 9

let val = 5 + 5;
val + 10;        // => 20

let add = fn(x, y) { return x + y };
add(1, 2);       // => 3

let callTwoTimes = fn(x, func) { func(func(x)) };
callTwoTimes(3, fn(x) { x + 1 }); // => 5

let newAdder = fn(x) { fn(n) { x + n } };
let addTwo = newAdder(2);
addTwo(2);       // => 4
```

